<?xml version="1.0" encoding="utf-8"?>
<chapter id="devguide">
  <title>Developer's Guide</title>

  <section id="devguide-tour"> <!--{{{-->
    <title>Developer Tour</title>

    <p>
      This section is brief a introduction describing how things are
      organized.
    </p>

    <subsection id="devguide-source-organisation"> <!--{{{-->
      <title>Source code</title>

      <p>
        The source code is organized into the following three layers:
      </p>

      <ul>

        <li><em>core</em> in <tt>src/core/</tt>. This is the base
          library written in C containing very basic functionality. This
          includes a generic hash table, a generic list, a safe
          growing-buffer implementation, lightweight type conversions,
          etc. This is considered legacy and contains all
          implementations which do <em>not</em> deal with e-mail (and
          related topics) or the user interface(s) (and related topics.)
          This is eventually to be separated into an souvereign project,
          maybe. The API already is designed a little towards
          <tt>libowfat</tt> so that a future migratation will be not so
          painful. The migration isn't done as the first step in the
          rewrite process since we're focusing on the core (logic)
          design and not on efficient sanity wrappers for system
          functions.</li>

        <li><em>libmuttng</em> in <tt>src/libmuttng/</tt>. This is the core
          part of the whole project as it contains most of the mail logic. It
          will provide one simple interface to mail storage independent from
          ``details'' like whether the actual storage is IMAP, POP3, NNTP or
          local storage methods such as Maildir or MBOX, whether there's
          support for a local cache or not, etc. Even the fact that some
          storage or transport methods may use network connections (thus
          involving encryption and authentication features, for example), will
          be be hidden from the application's point of view to achieve maximum
          portability and transparency. Also, it will contain transparent
          MIME-handling including digital encryption and signing, content types
          and handlers, etc. Besides these two major features, it'll provide
          utility classes and functions not at all related to mail but useful
          for the library and application implementation like a centralized
          debug output interface and generic signal handling.</li>

        <li><em>muttng</em> in <tt>src/muttng/</tt>. Built on top of the
          <em>core</em> and <em>libmuttng</em> layers, this group represents
          user interfaces and everything related. This includes support for
          reading configuration files, presenting data provided by the two
          underlying layers, etc. It will provide a convenient way to write new
          binaries with few code having access to all mail-related tasks. It
          will be split into two major parts: the actual user interface on side
          and all common logic (configuration, mail logic, etc.) on the other
          so that user interfaces only have to implement presenting data and
          nothing more.</li>

      </ul>

      <p>
        A very important design goal to keep by any means is the
        relationship between these three layers:
      </p>

      <ul>
        <li><em>core</em> must not depend on or make any kind of
          assumptions about either <em>libmuttng</em> or
          <em>muttng</em>. It may only rely on the standard C
          library.</li>
        <li><em>libmuttng</em> must not depend on or make any kind of
          assumptions about <em>muttng</em> but may utilize
          <em>core</em> and yet not make assumptions about how it
          internally works.</li>
        <li><em>muttng</em> may use any library it finds useful but, as
          all parts, must not make assumptions about internal
          implementation details or choices.</li>
      </ul>

      <p>
        The reason for this separation is to have good information
        hiding and a modular structure not only within these parts but
        also between them. As our main intention is to write a
        mail <em>user</em> agent, we move as much mail logic as possible
        out to libmuttng which then will be split into a separate
        project as core will be, too. In the end, mutt-ng is supposed to
        be a flexible client just using powerful libraries without
        implementing much logic itself.
      </p>

    </subsection>
    <!--}}}-->

    <subsection id="devguide-doc-organisation"> <!--{{{-->
      <title>Documentation</title>

      <p>
        All documentation in all places is written in a custom XML
        dialect to be translated via XSL into all other formats we need.
        These include DocBook as well as <man>doxygen</man>-based
        documentation. Language-independent parts are put in a separate
        directory and automated mechanisms for validity and completeness
        checks will be provided to ensure correct translated documentation.
      </p>

      <p>
        The basic organization is this:
      </p>

      <ul>

        <li>The ``master'' documentation is English. Where appropriate (see
          below), it'll be auto-generated and validated from the source code to
          avoid out-of-sync problems as far as possible.</li>

        <li>New is the goal to have all parts split over several files rather
          than only one big file. All files have to be valid XML and are checked
          for validity and completenes (where appropriate.)</li>

        <li>The basic manual structure for both, the user-only manual and this
          developer manual, is placed in <tt>doc/common/</tt> which contains
          other language-independent parts. For every language supported, upon
          change these will be copied to the language directories to have them
          under version control, too, on the one hand and to ease (the release)
          build process for users.</li>

      </ul>

    </subsection>
    <!--}}}-->

    <subsection id="devguide-build-organisation"> <!--{{{-->
      <title>Build system</title>

      <p>
        The build system is completely GNU make-based so that use of the autotools
        (such as <man>autoconf</man>) is avoided. To avoid clashes and misleading
        error messages with other flavors of <man>make</man>, all Makefiles are named
        <tt>GNUmakefile</tt> so that other make tools don't even find a Makefile.
      </p>

      <p>
        In the top-level source directory there're Makefile written for inclusion:
        they contain common logic, targets and rules as well as functions.
      </p>

      <p>
        These include Makefiles have to be included in all other Makefiles as necessary.
      </p>

      <p>
        All Makefiles are under version control except a custom one where users can
        set their own options (and any other make construct.) to avoid subversion conflicts
        if we change something.
      </p>

      <p>
        There's a common set of targets every Makefile in any directory must implement
        so that we have targets working for the whole tree.
      </p>

    </subsection>
    <!--}}}-->

  </section>
  <!--}}}-->
 
  <section id="devguide-style"> <!--{{{-->
    <title>Coding style</title>

    <subsection id="hacking-style-doc"> <!--{{{-->
      <title>Documentation</title>

      <p>
        To keep the code documented and consistent, this section lists
        some rules to keep.
      </p>

      <p>
        In general: document all files! Specify a doxygen header with at
        least the <tt>@@file</tt> and <tt>@@brief</tt> tags. For
        headers, the brief tag looks like:
      </p>

      <pre>
@@brief Interface: ...</pre>

      <p>and</p>
      <pre>
@@brief Implementation: ...</pre>

      <p>for source files.</p>

    </subsection>
    <!--}}}-->
  
    <subsection id="hacking-style-hdr"> <!--{{{-->
      <title>Header files</title>

      <p>
        For each source file, there is a header file listing all
        publicly accessable protos for the functions in the source
        file. All functions not listed in the header are to be declared
        static.
      </p>

      <p>
        Each header file is wrapped within the following preprocessor
        magic:
      </p>

      <pre>
#ifndef LIBMUTTNG_FOO_BAR_H
#define LIBMUTTNG_FOO_BAR_H
...
#endif</pre>

      <p>
        whereby the identifier is constructed from the filename under
        the <tt>src/</tt> directory,
        <tt>libmuttng/foo/bar.h</tt> in this case.
      </p>

    </subsection> <!--}}}-->

    <subsection id="hacking-style-misc"> <!--{{{-->
      <title>Misc.</title>

      <p>
        For debugging, make the code print debug info by semantic, not
        just any number.
      </p>

    </subsection> <!--}}}-->

  </section>
  <!--}}}-->

  <section id="devguide-build"> <!--{{{-->
    <title>Build system</title>

    <subsection id="devguide-build-config"> <!--{{{-->
      <title>Configuration: GNUmakefile.config and GNUmakefile.config.mine</title>

      <p>
        The user configuration Makefile is <tt>GNUmakefile.config.mine</tt>
        in the top-level source directory. It may contain any make logic.
      </p>

      <p>
        Any Makefile including it must include <tt>GNUmakefile.config</tt>
        directly afterwards like in <docref type="listing" href="sample-libmuttng-build-config">include
          example</docref>.
      </p>

      <listing lang="make" id="sample-libmuttng-build-config"
        title="Include configuration"
        href="makefile_config"/>

      <p>
        <tt>GNUmakefile.config</tt> interprets and completes internal options
        set in the custom file:
      </p>

      <ul>
        <li>for the compilers, it sets up
          <docref type="table" href="table-make-env1">variables for compilers and flags</docref>
          depending on <tt>CCSTYLE</tt></li>
        <li>it checks whether the dependency file <tt>./.depend</tt> exists and
          includes it</li>
        <li>for <tt>DEBUG=1</tt>, it sets up <tt>CFLAGS</tt>, <tt>CXXFLAGS</tt>
          and <tt>LDFLAGS</tt> correctly</li>
        <li>it defines the operating system and sets compiler flags
          accordingly (e.g. <tt>-DFREEBSD</tt> for FreeBSD, <tt>-DSUNOS</tt>
          for solaris, etc.) The operating system value is set as
          <tt>$(MYOS)</tt></li>
        <li>it sets up compiler and linker flags to contain the required
          paths for Unit++ derived from the configured <tt>$(UNITPPDIR)</tt></li>
        <li>it searches <env>PATH</env> for the paths of
          <docref type="table" href="table-make-tools">tools required</docref>.</li>
        <li>according to the XSL processor chosen via <tt>$(XSLPROC)</tt>,
          it defines the following two functions: <tt>doxslt_s</tt> and
          <tt>doxslt_m</tt>. The first does transformation to a single
          output file while the latter does transformation to multiple output files
          (splitting these up is required for Xalan Java whose <tt>-out</tt>
          option cannot be set to a directory.) These functions take the following
          mandatory arguments (ordered):
          <ul>
            <li>XML source file</li>
            <li>XSL stylesheet file</li>
            <li>XML output file</li>
            <li>output language passed to processors as the value for the
              <tt>l10n.gentext.default.language</tt> parameter. This is bad
              modularization as this parameter only has an effect on DocBook
              but passing to other transformations shouldn't do harm.</li>
          </ul>
        </li>
      </ul>

      <p>
        <tab cols="2" texstr="l|l" id="table-make-env1">
          <cap>Make environment</cap>
          <th>
            <tr><td>Make variable</td><td>Meaning</td></tr>
          </th>
          <tb>
            <tr><td><tt>CC</tt></td><td>C compiler</td></tr>
            <tr><td><tt>CXX</tt></td><td>C++ compiler</td></tr>
            <tr><td><tt>CFLAGS</tt></td><td>C compiler flags</td></tr>
            <tr><td><tt>CXXFLAGS</tt></td><td>C++ compiler flags</td></tr>
            <tr><td><tt>DEPFLAGS</tt></td><td>C/C++ compiler flags for dependencies</td></tr>
            <tr><td><tt>AR</tt></td><td>path to <man>ar</man></td></tr>
            <tr><td><tt>RANLIB</tt></td><td>path to <man>ranlib</man></td></tr>
          </tb>
        </tab>
      </p>

      <p>
        <tab cols="2" texstr="l|l" id="table-make-tools">
          <cap>Make tools</cap>
          <th>
            <tr><td>Tool</td><td>Make variable</td></tr>
          </th>
          <tb>
            <tr><td><man>doxygen</man></td><td><tt>DOXYGEN</tt></td></tr>
            <tr><td><man>tidy</man></td><td><tt>TIDY</tt></td></tr>
            <tr><td><man>xgettext</man></td><td><tt>XGETTEXT</tt></td></tr>
            <tr><td><man>msgmerge</man></td><td><tt>MSGMERGE</tt></td></tr>
            <tr><td><man>msgfmt</man></td><td><tt>MSGFMT</tt></td></tr>
            <tr><td><man>pdflatex</man></td><td><tt>PDFLATEX</tt></td></tr>
            <tr><td><man>latex</man></td><td><tt>LATEX</tt></td></tr>
            <tr><td><man>makeindex</man></td><td><tt>MAKEINDEX</tt></td></tr>
          </tb>
        </tab>
      </p>

      <p>
        In any Makefile, targets can be setup depending on whether a tool is present
        or not via, see <docref type="listing" href="sample-libmuttng-build-conditional">conditional
          example</docref>.
      </p>

      <listing lang="make" id="sample-libmuttng-build-conditional"
        title="Conditional targets"
        href="makefile_conditional"/>

      <p>
        This only runs <man>doxygen</man> it it's found in <env>PATH</env>. If, in addition,
        <man>tidy</man> is found too, it'll also be called. If doxygen isn't present,
        the <tt>srcdoc</tt> rule does nothing.
      </p>

    </subsection>
    <!--}}}-->

    <subsection id="devguide-build-whereis"> <!--{{{-->
      <title>Path search: GNUmakefile.whereis</title>

      <p>
        The include Makefile <tt>GNUmakefile.whereis</tt> defines a
        function called <tt>whereis</tt>. This searches through the
        environment variable <env>PATH</env> and returns the full path
        found or the given default fallback.
      </p>

      <p>
        The arguments for <tt>whereis</tt> are in order:
      </p>

      <ul>
        <li>name of binary to find</li>
        <li>fallback</li>
      </ul>

      <p>
        For example, the full path to <man>vi</man> can be obtained via
        the call shown in the <docref type="listing" href="sample-libmuttng-build-whereis-call1"
          >first whereis call example</docref>.
      </p>

      <listing lang="make" id="sample-libmuttng-build-whereis-call1"
        title="Calling whereis 1"
        href="makefile_whereis_call1"/>


      <p>
        If the binary is found, <tt>GREAT_EDITOR</tt> will contain its path and
        will be empty otherwise. A check for it could be implemented as shown in the
        <docref type="listing" href="sample-libmuttng-build-whereis-use">whereis usage example</docref>.
      </p>

      <listing lang="make" id="sample-libmuttng-build-whereis-use"
        title="Using whereis"
        href="makefile_whereis_use"/>

      <p>
        An example of a non-empty default is show in the
        <docref type="listing" href="sample-libmuttng-build-whereis-call2">second whereis call example</docref>
        which will search for the <man>vim</man> binary: if it's found,
        <tt>GREAT_EDITOR</tt> contains its path but just <tt>vi</tt> otherwise.
      </p>

      <listing lang="make" id="sample-libmuttng-build-whereis-call2"
        title="Calling whereis 2"
        href="makefile_whereis_call2"/>

    </subsection>
    <!--}}}-->

    <subsection id="devguide-build-subdirs"> <!--{{{-->
      <title>Directory traversal: GNUmakefile.subdirs</title>

      <p>
        The file <tt>GNUmakefile.subdirs</tt> defines targets to
        be called recursively. To make use of it, define a variable
        named <tt>SUBDIRS</tt> at the beginning of a Makefile. Then,
        the following targets can be used on these directories:
      </p>

      <ul>
        <li><tt>all</tt>: <tt>subdir</tt></li>
        <li><tt>clean</tt>: <tt>subdirclean</tt></li>
        <li><tt>doc</tt>: <tt>subdirdoc</tt></li>
        <li><tt>depend</tt>: <tt>subdirdepend</tt></li>
        <li><tt>test</tt>: <tt>subdirtest</tt></li>
      </ul>

      <p>
        For example, to have all these targets for the subdirectories
        <tt>foo</tt> and <tt>bar</tt>, use the basic structure as shown
        in the <docref type="listing" href="sample-libmuttng-build-structure">general makefile structure</docref>
        listing.
      </p>

      <listing lang="make" id="sample-libmuttng-build-structure"
        title="General Makefile structure"
        href="makefile_structure"/>
      
    </subsection>
    <!--}}}-->

    <subsection id="devguide-build-compile"> <!--{{{-->
      <title>Compilation: GNUmakefile.compile</title>

      <p>
        The files <tt>GNUmakefile.compile_c</tt> and <tt>GNUmakefile.compile_cpp</tt>
        contain everything necessary to compile sources either using a C or C++ compiler
        respectively.
      </p>

      <p>
        Use is as easy as show in the <docref type="listing"
          href="sample-libmuttng-build-compile">compilation makefile example</docref>.
      </p>

      <listing lang="make" id="sample-libmuttng-build-compile"
        title="Compiling files"
        href="makefile_compile"/>

      <p>
        This will compile the files
        <tt>foo.c</tt> and <tt>bar.c</tt> into the archive <tt>libfoobar.a</tt> using
        the C compiler.
      </p>

      <p>
        For C++ sources, the files must be named <tt>foo.cpp</tt> and <tt>bar.cpp</tt>
        and instead of <tt>GNUmakefile.compile_c</tt> the file
        <tt>GNUmakefile.compile_cpp</tt> must be included.
      </p>

      <p>
        Either of these also define the following targets:
      </p>

      <ul>
        <li><tt>clean</tt>: remove any temporary, object and archive files</li>
        <li><tt>depend</tt>: run the C/C++ compiler and put the dependency
          tracking info for <man>make</man> into <tt>./.depend</tt></li>
      </ul>
      
    </subsection>
    <!--}}}-->

    <subsection id="devguide-build-adding"> <!--{{{-->
      <title>Adding subdirectories</title>

      <p>
        When adding directories somewhere, please make sure the Makefile
        includes at least the files previously shown in the 
        <docref type="listing" href="sample-libmuttng-build-config">include example</docref>.
      </p>

      <p>
        Also, it must define the following targets so that they work
        over the complete tree:
      </p>

      <ul>
        <li><tt>all</tt>: perform building all</li>
        <li><tt>clean</tt>: perform cleanup so that only files for a release remain</li>
        <li><tt>test</tt>: perform all automated tests</li>
        <li><tt>depend</tt>: perform all preparation required for
          <tt>all</tt> target</li>
      </ul>
      
    </subsection>
    <!--}}}-->

  </section>
  <!--}}}-->
  
  <section id="devguide-docs"> <!--{{{-->
    <title>Documentation</title>

    <subsection id="devguide-docs-overview"> <!--{{{-->
      <title>Organisation</title>

      <p>
        The documentation includes the user manual, the developer's guide and the
        (new) mutt-ng homepage. All is written in a custom XML dialect (describes later
        in this chapter) and transformed into the following formats:
      </p>

      <ul>
        <li>DocBook: this meta format is used to transform everything into
          fancy HTML</li>
        <li>Doxygen: this format makes doxygen pick up the documentation to
          integrate it into the source's docs</li>
        <li>LaTex: this format is used to generate PDF and PostScript output</li>
      </ul>

      <p>
        As far as possible, documentation is automatically generated (better: stripped)
        from the source code to avoid out-of-sync problems. Details of auto-generation
        are described later in this chapter.
      </p>

      <p>
        The documentation is multi-lingual. Details are described later in this
        chapter.
      </p>

    </subsection>
    <!--}}}-->

    <subsection id="devguide-docs-layout"> <!--{{{-->
      <title>Directory layout</title>

      <p>
        The <tt>doc/</tt> directory contains the following subdirectories:
      </p>

      <ul>
        <li><tt>common/</tt>: it contains all language-independent fractions of any
          part of the docs</li>
        <li><tt>css/</tt>: it contains HTML CSS stylesheets for use with doxygen- and
          DocBook-generated HTML output</li>
        <li><tt>xsl/</tt>: it contains the XSL stylesheets used for transformations</li>
        <li><tt>manual_[lang]/</tt>: it contains all input and output files for
          the manual in a specific language</li>
        <li><tt>homepage_[lang]/</tt>: it contains all input and output files for
          the homepage in a specific language</li>
        <li><tt>examples/</tt>: it contains all examples contained in the manual
          (such as programming or configuration examples.)</li>
        <li><tt>tex/</tt>: all files related to LaTeX-processing</li>
      </ul>

      <p>
        To have all files correctly setup when getting a working copy or making a
        release, some files are identical and copied from a ``master'' source to
        several directories. This is important to mention as a change made to a copy
        will get lost, changes should be made to the master only. The master documents
        and its copies are:
      </p>

      <ul>
        <li><tt>css/muttng.css</tt>: the main CSS stylesheet it's copied to all
          <tt>manual_*</tt> and all <tt>homepage_*</tt> directories</li>
        <li><tt>common/manual-full.xml</tt> and <tt>common/manual-user.xml</tt>:
          the actual manual files are maintained like this to have a common structure
          for all translations. These are copied to all <tt>manual_*</tt> directories.
        </li>
      </ul>

      <p>
        To ensure that at least the programming examples are up-to-date and compile,
        they're not only fragments but complete examples that can be compiled, linked
        and, if needed, even executed.
      </p>

    </subsection>
    <!--}}}-->

    <subsection id="devguide-docs-dialect"> <!--{{{-->
      <title>XML Dialect</title>

      <p>
        This section describes the custom XML dialect used for writing all of
        the documentation (including descriptions for variables and everything
        else.)
      </p>

      <subsubsection id="devguide-docs-dialect-structure" title="Document structure"> <!--{{{-->
      
        <p>
          The manual is wrapped in a <tt>manual</tt> tag. It contains the following two
          tags:
        </p>

        <ul>

          <li><tt>head</tt>: This describes a header for the document. Its title
            is enclosed in a <tt>title</tt> tag, the list of all authors in an
            <tt>authors</tt> tag. Within the latter, the <tt>author</tt> tag
            lists any number of authors with the following tags:
            <tt>surname</tt>, <tt>firstname</tt> and <tt>email</tt>.</li>

          <li><tt>content</tt>: This describes the content for the document, that
            is, one or more <tt>chapter</tt> tags.</li>

        </ul>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-docs-dialect-sectioning" title="Chapters and sections"> <!--{{{-->

        <p>
          Within the mentioned <tt>chapter</tt> tags, the following tags are to
          be used for grouping text: <tt>section</tt>, <tt>subsection</tt>
          and <tt>subsubsection</tt>.
          All sectioning tags <em>must</em> have an <tt>id</tt> attribute with
          the name of the section. For nesting them, please specify prefixes to
          avoid clashes. For example, within a chapter with <tt>id="intro"</tt>
          and there for a section mentioning the mailing lists, use
          <tt>id="intro-mailing"</tt>. As all output formats we use have a flat
          ``labeling'' or ``anchor'' namespace, we create our namespaces like
          this.
        </p>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-docs-dialect-text" title="Text"> <!--{{{-->

        <p>        
          All texts are to be grouped within <tt>p</tt> tags (``p'' as in
          paragraph.)
        </p>

        <p>
          For ordinary text, please use the following to fill the manual with
          semantics rather than flat text or any layout:
        </p>

        <ul>

          <li><em>special semantics</em>. There will be much more, but currently
            the following tags are to be used for specifying a special semantic
            for a word (mainly these are needed for auto-indexing so that
            one can actually find something in the documentation):
            <ul>
              <li><tt>val</tt>: when refering to (possible/default/...) values
                for variables.</li>
              <li><tt>hdr</tt>: when refering to a commonly used header</li>
              <li><tt>enc</tt>: when refering to transport encodings (such
                as <enc>quoted-printable</enc> or <enc>us-ascii</enc></li>
              <li><tt>env</tt>: when refering to environment variables</li>
            </ul>
          </li>

          <li><em>listings</em>. To specify lists or listings, the following tags
            are available:
            <ul>
              <li><tt>ul</tt>: a non-numbered itemized list</li>
              <li><tt>li</tt>: an item of any of these lists</li>
            </ul>
          </li>

          <li><em>misc.</em>: The following are not the optimal solution as they
            imply layout semantics already but here we go:
            <ul>
              <li><tt>tt</tt>: typewriter font</li>
              <li><tt>em</tt>: emphasise</li>
              <li><tt>b</tt>: bold font</li>
            </ul>
          </li>

        </ul>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-docs-dialect-referencing" title="Referencing"> <!--{{{-->

        <p>
          For specifying references, a distinction is made to what target
          a reference is made:
        </p>

        <ul>
          <li><docref type="table" href="tab-ref-tags">some tags</docref> don't
            accept attributes but the target specified as text</li>
          <li>for document-internal references, the 
            <docref type="table" href="tab-docref-attrs"><tt>docref</tt> tag is to
              be used</docref></li>
          <li>for references to manual pages, the <docref
              type="table" href="tab-man-attrs"><tt>man</tt> tag</docref> with an optional
            section attribute is to be used</li>
        </ul>

        <p>
          <tab cols="2" texstr="l|c|l" id="tab-ref-tags"> <!--{{{-->
            <cap>reference tags</cap>
            <th>
              <tr><td>Tag</td><td>Meaning</td></tr>
            </th>
            <tb>
              <tr><td><tt>email</tt></td><td>an email address</td></tr>
              <tr><td><tt>web</tt></td><td>a web address</td></tr>
              <tr><td><tt>varref</tt></td><td>referencing a configuration variable</td></tr>
              <tr><td><tt>cmdref</tt></td><td>referencing a configuration command</td></tr>
              <tr><td><tt>funcref</tt></td><td>referencing a function</td></tr>
            </tb>
          </tab> <!--}}}-->
        </p>

        <p>
          <tab cols="3" texstr="l|c|l" id="tab-man-attrs"> <!--{{{-->
            <cap><tt>man</tt> tag attributes</cap>
            <th>
              <tr><td>Attribute</td><td>Mandatory</td><td>Meaning</td></tr>
            </th>
            <tb>
              <tr><td><tt>sect</tt></td><td><tt>no</tt></td><td>Manual page section, default: 1</td></tr>
            </tb>
          </tab> <!--}}}-->
        </p>

        <p>
          <tab cols="3" texstr="l|c|l" id="tab-docref-attrs"> <!--{{{-->
            <cap><tt>docref</tt> tag attributes</cap>
            <th>
              <tr><td>Attribute</td><td>Mandatory</td><td>Meaning</td></tr>
            </th>
            <tb>
              <tr><td><tt>type</tt></td><td><tt>yes</tt></td><td>Type of link's end (e.g. ``table''.)</td></tr>
              <tr><td><tt>href</tt></td><td><tt>yes</tt></td><td>Target (document-internal ID)</td></tr>
            </tb>
          </tab> <!--}}}-->
        </p>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-docs-dialect-variables" title="Documenting variables"> <!--{{{-->

        <p>
          Internally, variables are documented like this (this does <em>not</em> count for
          the description of a variable but the variable as a whole within the
          manual) (<em>note: this is auto-generated</em>):
        </p>

        <ul>
          <li>all variables are wrapped within a <tt>descriptions</tt> tag</li>
          <li>within this, there's any number of <tt>variable</tt> tags containing
            the following attributes: <tt>name</tt> specifies the name of the
            variable, <tt>type</tt> specifies its type</li>
          <li>within a <tt>variable</tt> tag, the following tags will be used:
            <ul>
              <li><tt>init</tt>: initial or default value</li>
              <li><tt>sig</tt>: whether a change of it will cause a signal be emitted</li>
              <li><tt>descr</tt>: its description</li>
            </ul>
          </li>
        </ul>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-docs-dialect-functions" title="Documenting functions"> <!--{{{-->

        <p>
          Internally, functions are documented like this
          (<em>note: this is auto-generated</em>):
        </p>

        <ul>
          <li>all functions are wrapped within a <tt>descriptions</tt> tag</li>
          <li>within this, there's any number of <tt>context</tt> tags containing
            the following attributes: <tt>name</tt> specifies the name of the
            context. As functions are grouped by context (that is: by menu) where
            they may have different bindings, each function may appear several
            times within different <tt>context</tt> tags.</li>
          <li>within the <tt>context</tt> tag, all functions it contains are
            given via <tt>function</tt> tags. Each <tt>function</tt> tag must contain the
            following attributes: <tt>name</tt> specifies the name a user
            may bind to it, <tt>default</tt> specifies the default key binding
            and <tt>group</tt> specifies to which semantic group the function belongs
            within the context as defined in <tt>src/muttng/event/GROUPS</tt>.</li>
          <li>the text within the <tt>function</tt> tag is just the functions's
            summary to appear in the help menus</li>
        </ul>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-docs-dialect-listings" title="Embedding listrings"> <!--{{{-->

        <p>
          Eventually there will be several types of listings each treated individually
          for the output.
        </p>

        <p>
          The following two tags can be used for specifying listings:
        </p>

        <ul>
          <li><tt>listing</tt>: make listing from an external file</li>
          <li><tt>inlinelisting</tt>: make listing inline from given text</li>
        </ul>

        <p>
          Both require these attributes:
        </p>

        <ul>
          <li><tt>lang</tt> specifies the language. For most of the output this is irrelevant
            but for LaTeX output and the <tt>listings.sty</tt> package we have syntax-highlighting
            automatically. The following languages are supported:
            <ul>
              <li><tt>cpp</tt> for C++</li>
              <li><tt>make</tt> for GNU make</li>
              <li><tt>muttngrc</tt> for muttng's configuration syntax</li>
            </ul>
          </li>
        </ul>

        <p>
          The <tt>listing</tt> tag also requires these attributes in addition:
        </p>

        <ul>
          <li><tt>id</tt> specifies a document-internal ID to link to listings. As for
            any other ID attributes, we fake a namespace or hierarchy by prefixes. At least all
            sample listings must have <tt>sample-</tt> as prefix for this attribute.</li>
          <li><tt>title</tt> is the title to specify (if at all which depends on the output
            format.)</li>
          <li><tt>href</tt> specifies the filename in the <tt>doc/examples/</tt> directory.</li>
        </ul>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-docs-dialect-tables" title="Tables"> <!--{{{-->

        <p>
          Tables have to be specified within a
          <docref type="table" href="tab-tab-attrs"><tt>tab</tt> tag with
            proper attributes</docref>. Within a table, there must be a header
          within a <tt>th</tt> tag and a body within a <tt>tb</tt> tag. Within each
          of them, there's any number of rows wrapped in <tt>tr</tt>. As a row consists
          of multiple columns, within <tt>tr</tt> there's any number of <tt>td</tt> tags
          for columns.
        </p>

        <p>
          The caption is specified via a <tt>cap</tt> tag within the table.
        </p>

        <p>
          <tab cols="3" texstr="l|c|l" id="tab-tab-attrs"> <!--{{{-->
            <cap><tt>tab</tt> tag attributes</cap>
            <th>
              <tr><td>Attribute</td><td>Mandatory</td><td>Meaning</td></tr>
            </th>
            <tb>
              <tr><td><tt>cols</tt></td><td><tt>yes</tt></td><td>Number of columns</td></tr>
              <tr><td><tt>texstr</tt></td><td><tt>yes</tt></td><td>Layout string for LaTeX's <tt>longtable</tt></td></tr>
              <tr><td><tt>id</tt></td><td><tt>yes</tt></td><td>Document-internal ID</td></tr>
            </tb>
          </tab> <!--}}}-->
        </p>

      </subsubsection>
      <!--}}}-->

    </subsection>
    <!--}}}-->

    <subsection id="devguide-docs-auto"> <!--{{{-->
      <title>Auto-generation</title>

      <p>
        The function and variable descriptions are generated
        to our custom XML dialect automatically.
      </p>

      <subsubsection id="devguide-docs-auto-variables" title="Variables"> <!--{{{-->
      
        <p>
          For variables, <tt>src/muttng/config/config.pl</tt> is used. The
          documentation process for variables is the same as it was before:
        </p>

        <ul>
          <li>all documentation is expected between the words <tt>START</tt>
            and <tt>END</tt> (commented) in <tt>set_command.cpp</tt></li>
          <li>the variable definition for the source is one line</li>
          <li><em>below</em> is a comment block whereby each line to be
            treated as part of the description for a variable starts with
            <em>two</em> asterisks. The tags are the same as for
            all other documentation.
          </li>
        </ul>

        <p>
          The auto-generated files are:
        </p>

        <ul>
          <li><tt>doc/manual_en/var_def.xml</tt>: contains a simple listing
            of all variables found. As English is expected to be always in sync
            with the source code, this file will be used to validate and/or
            check other translations for completeness</li>
          <li><tt>doc/manual_en/var_descr.xml</tt>: contains the full English
            documentation</li>
        </ul>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-docs-auto-functions" title="Functions"> <!--{{{-->

        <p>
          For functions, <tt>src/muttng/event/event.pl</tt> is used. It parses the
          following file in the <tt>event</tt> subdirectory for documentation:
          <tt>EVENTS</tt>. This has space or tab separated fields with the
          following meanings for documentation:
        </p>

        <ul>
          <li>1st field: the context IDs defined in <tt>CONTEXTS</tt></li>
          <li>3rd field: the function's name</li>
          <li>4th field: the group IDs defined in <tt>GROUPS</tt></li>
          <li>5th field: the default keybinding</li>
          <li>rest of the line: short description</li>
        </ul>

        <p>
          The auto-generated files are:
        </p>

        <ul>
          <li><tt>doc/manual_en/func_def.xml</tt>: contains a simple listing
            of all functions found. As English is expected to be always in sync
            with the source code, this file will be used to validate and/or
            check other translations for completeness</li>
          <li><tt>doc/manual_en/func_descr.xml</tt>: contains the full English
            documentation</li>
        </ul>

      </subsubsection>
      <!--}}}-->

    </subsection>
    <!--}}}-->

    <subsection id="devguide-docs-trans"> <!--{{{-->
      <title>Translations</title>

      <p>
        Though the English documents are considered the ``master'' documents,
        they're only a treated as a translation, too. This section describes how to
        add and maintain a translation.
      </p>

      <subsubsection id="devguide-docs-trans-files" title="Mandatory files"> <!--{{{-->

        <p>
          As mentioned when explaining the directory layout, the manual
          files are copied from a master document in the <tt>common/</tt> to a
          language directory. The manual files define the necessary structure which is
          technically implemented using XInclude. Thus, a language directory must
          contain a set of files:
        </p>

        <ul>
          <li><tt>head.xml</tt>: it must contain a <tt>head</tt> tag as the document
            root and list all details for the manual: title and authors.</li>
          <li><tt>trans.xml</tt>: it must contain a set of translated special words described
            later in this document.</li>
          <li><tt>intro.xml</tt>: it must contain the introductionary chapter</li>
          <li><tt>build.xml</tt>: it must contain the chapter explaining the build
            process</li>
          <li><tt>config.xml</tt>: it must contain the configuration documentation</li>
          <li><tt>reference.xml</tt>: it must contain the reference chapter. This document
            must include the following two files: <tt>var_descr.xml</tt> for variable
            descriptions and <tt>func_descr.xml</tt> for functions. For the English
            documentation, both are automatically generated.</li>
          <li><tt>devguide.xml</tt>: it must contain the developer's guide</li>
          <li><tt>ack.xml</tt>: it must contain acknowledgements. This file must include
            the following files in the <tt>doc/common/</tt> directory:
            <ul>
              <li><tt>dev_muttng.xml</tt>: list of mutt-ng developers</li>
              <li><tt>ack_muttng.xml</tt>: list of people who contributed to mutt-ng</li>
              <li><tt>ack_mutt.xml</tt>: list of people who contributed to mutt</li>
            </ul>
          </li>
        </ul>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-docs-trans-add" title="Adding a new translation"> <!--{{{-->

        <p>
          When adding a new translation, the easiest way is to make a copy of the
          English translation: just copy all XML files except <tt>manual-docbook</tt>
          to the corresponding language directory and add them to version control.
        </p>

        <p>
          Afterwards, the following files should be translated first as they contain
          only a few words to translate:
        </p>

        <ul>
          <li><tt>head.xml</tt></li>
          <li><tt>reference.xml</tt></li>
          <li><tt>ack.xml</tt> and</li>
          <li><tt>trans.xml</tt></li>
        </ul>

        <p>
          For these, what to translate how should be pretty self-explanatory so that
          not much documentation is put here. In <tt>trans.xml</tt> the comments and
          English translations should be sufficient.
        </p>

      </subsubsection>
      <!--}}}-->

    </subsection>
    <!--}}}-->

    <subsection id="devguide-docs-notes"> <!--{{{-->
      <title>Notes</title>

      <p>
        For LaTeX output escaping of several characters is required.
        With XSL this could be done using a recursively called function which
        has two major drawbacks: it's terribly slow as the manual is getting
        closer to being complete and it doesn't work based on semantics (for
        example, within a <tt>verbatim</tt> environment, we do not want to
        escape special characters but elsewhere we want.) To solve this,
        the file <tt>doc/tex/muttng.sty</tt> contains a macro named
        <tt>uglyesc</tt> which ``escapes''--or better: fakes escaping--using
        the <tt>listinline</tt> macro of the <tt>listings.sty</tt> package.
        As the <tt>uglyesc</tt> command switches to typewriter, most of the
        typewriter-layout is done with it rather than with LaTeX's own
        <tt>texttt</tt>. As a consequence, whenever using a word which may
        require escaping, use the <tt>tt/</tt> tag.
      </p>

    </subsection>
    <!--}}}-->

  </section>
  <!--}}}-->

  <section id="devguide-core"> <!--{{{-->
    <title>Core</title>
 
    <!-- this should be the last one!!!1!! -->

      <subsection id="devguide-core-extending"> <!--{{{-->
      <title>Extending the library</title>

      <p>
        When making any extensions are chaning an implementation,
        please make sure to run and maybe add/change/extend one
        of the unit tests to verify it's working.
      </p>

    </subsection>
    <!--}}}-->
    
  </section>
  <!--}}}-->

  <section id="devguide-libmuttng"> <!--{{{-->
    <title>Libmuttng</title>

    <subsection id="devguide-libmuttng-features"> <!--{{{-->
      <title>Features</title>

      <p>
        Libmuttng is in the <tt>src/libmuttng/</tt> subdirectory
        and provides the following features:
      </p>

      <ul>

        <li><em>basic services</em> of interest for the whole library and
          application: signal handling and debug support.</li>

        <li><em>mailbox support</em> includes: IMAP, POP3, NNTP, Maildir, MH,
          MBOX and MMDF. The Mailbox abstraction layer works transparently and is
          URL-driven, that is, the client doesn't need to care about and that
          there are different storage formats</li>

        <li><em>caching</em> is transparent for some mailbox types: IMAP, NNTP,
          Maildir and MH. Again, as the Mailbox layer is abstract, so is the
          caching layer which means that clients don't take note of caching
          existing.</li>

        <li><em>MIME and crypto</em> support via either local utilities such as
          <man>pgp</man>/<man>gpg</man> or via gpgme for crypto and support for
          the mailcap mechanism, using <man>file</man> and the like. Decoding
          will be transparent for client, too.</li>

      </ul>

    </subsection>
    <!--}}}-->

    <subsection id="devguide-libmuttng-signal"> <!--{{{-->
      <title>Signal handling</title>

      <p>
        Libmuttng contains a very simple, easy to use and typesafe signal
        handling interface. Though signals will be used within the library,
        too, it's use is not limited to connecting handlers in the client
        to events in the library but may also be used to pass signals
        only within the client.
      </p>

      <p>
        We started off with the implementation from:
        <web>http://lists.trolltech.com/qt-interest/1997-07/msg00158.html</web>
        and extended/modified it to fit our needs.
      </p>

      <subsubsection id="devguide-libmuttng-signal-declare" title="Declaring"> <!--{{{-->

        <p>
          Declaring a signal is as easy as:
        </p>

        <pre>
SignalX&lt;type of arg1,type of arg2,...,type of argX&gt; signalname;</pre>

        <p>
          whereby <tt>X</tt> is the number of arguments.
        </p>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-libmuttng-signal-connect" title="Connecting"> <!--{{{-->

        <p>
          Connecting to a signal is easy, too. Each handler must fullfill
          the following two requirements:
        </p>

        <ul>
          <li>it must return <tt>bool</tt> specifying whether it succeeded
            or not</li>
          <li>it must take exactly the number and type of arguments the
            signal was declared with</li>
        </ul>

        <p>
          Due to overloading, connecting to a signal is always the same:
        </p>

        <pre>
connectSignal (signal, object, Object::handler)</pre>

        <p>
          ..whereby:
        </p>

        <ul>
          <li><tt>signal</tt> is the signale declared elsewhere</li>
          <li><tt>object</tt> is an instance of an object containg a handler</li>
          <li><tt>Object::handler</tt> is the actual handler method. Here, <tt>Object</tt>
            is the <em>classname</em> of <tt>object</tt></li>
        </ul>

        <p>
          In most cases, the object will be <tt>this</tt> though any method may connect
          everything it wants to every signal it wishes to.
        </p>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-libmuttng-signal-emit" title="Emitting"> <!--{{{-->

        <p>
          Emitting a signal can be done by every method having access to
          the signal's declaration and works like this:
        </p>

        <pre>
signal.emit (arguments);</pre>

        <p>
          For a given signal, all handlers are executed in some order while
          each of them returns success. As soon as one handlers reports failure,
          the emit process will abort.
        </p>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-libmuttng-signal-disconnect" title="Disonnecting"> <!--{{{-->

        <p>
          Disconnecting from a signal is highly recommended to take
          place in the object's destructor as a crash upon the next emit after
          destruction is likely. Though any object may connect as many handlers as it
          likes to a signal, it's currently only supported to unbind all
          handlers of an object <em>for a specific signal</em> at once like so:
        </p>

        <pre>
disconnectSignals (signal, object);</pre>

        <p>
          This must be done for every signal the object connected a(ny) handler(s)
          to. In most cases, object is simply <tt>this</tt>.
        </p>

      </subsubsection>
      <!--}}}-->

      <subsubsection id="devguide-libmuttng-signal-example" title="Example"> <!--{{{-->

        <p>
          The <docref type="listing" href="sample-libmuttng-signal">Signal example</docref> shows how
          to handle signals: it contains a class <tt>Sig</tt> which contains nothing but
          the signal declaration and a class <tt>Handler</tt> which simply catches a signal
          and prints the argument passed through all handlers.
        </p>
        
        <listing lang="cpp" id="sample-libmuttng-signal"
          title="Signal example"
          href="libmuttng_signal.cpp"/>

      </subsubsection>
      <!--}}}-->
 
    </subsection>
    <!--}}}-->

    <subsection id="devguide-libmuttng-mailbox"> <!--{{{-->
      <title>Mailbox handling</title>

      <p>
        Libmuttng contains transparent support for the following
        types of mailboxes: IMAP, POP3, NNTP, Maildir, MH, MBOX
        and MMDF. Also, caching and filtering (for local mailboxes
        only) is transparently hidden behind the general Mailbox
        class interface.
      </p>

      <p>
        Though any client using libmuttng can access the different
        mailbox types derived from Mailbox directly, it's recommended
        to use the generic interface only.
      </p>

      <p>
        As part of hiding implementations behind the common interface,
        all mailboxes can be accessed via an URL only.
      </p>

      <subsubsection id="devguide-libmuttng-mailbox-create" title="Creating a mailbox"> <!--{{{-->
      
        <p>
          Creating a new instance of a mailbox based on the URL (other ways
          are not planned), use the Mailbox::fromUrl() function as shown
          <docref type="listing" href="sample-libmuttng-mailbox-create">in the example</docref>.
        </p>

        <listing lang="cpp" id="sample-libmuttng-mailbox-create"
          title="Create Mailbox from URL"
          href="libmuttng_mailbox_create.cpp"/>

      </subsubsection>
      <!--}}}-->

    </subsection>
    <!--}}}-->

    <!-- these should be the last -->

    <subsection id="devguide-libmuttng-auto"> <!--{{{-->
      <title>Auto-generated code</title>

      <p>
        <em>Signal implementation.</em> As unfortunately we cannot overload
        templates by the number of arguments, we need to specify the same
        implementation for every argument count we need. Thus, this is done by
        a script: <tt>src/libmuttng/signal.pl</tt> prints the commented
        implementation to <tt>stdout</tt> so that the makefile puts it into
        <tt>muttng_signal.h</tt>. When making changes, modify <tt>muttng_signal.h</tt> to verify it
        works (plus maybe add a unit test) and adjust signal.pl to print the
        changed code.
      </p>

    </subsection>
    <!--}}}-->

      <subsection id="devguide-libmuttng-extending"> <!--{{{-->
      <title>Extending the library</title>

      <p>
        When making extensions to the library and adding classes,
        please make sure to derive them from the Libmuttng base
        class to have debugging support and future extensions
        already in your class.
      </p>

      <p>
        When making any extensions are chaning an implementation,
        please make sure to run and maybe add/change/extend one
        of the unit tests to verify it's working.
      </p>

    </subsection>
    <!--}}}-->
    
  </section>
  <!--}}}-->

  <section id="devguide-muttng"> <!--{{{-->
    <title>Muttng</title>
 
    <!-- these should be the last -->

    <subsection id="devguide-muttng-auto"> <!--{{{-->
      <title>Auto-generated code</title>

    </subsection>
    <!--}}}-->

    <subsection id="devguide-muttng-extending"> <!--{{{-->
      <title>Extending</title>

      <p>
        When making extensions to the library and adding classes,
        please make sure to derive them from the Muttng base
        class to have debugging support and future extensions
        already in your class.
      </p>

      <p>
        When making any extensions are chaning an implementation,
        please make sure to run and maybe add/change/extend one
        of the unit tests to verify it's working.
      </p>

    </subsection>
    <!--}}}-->
    
  </section>
  <!--}}}-->

</chapter>
